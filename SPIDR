#!/usr/local/bin/perl
use strict; use warnings;
# FreeBSD Only
# unix or you a bitch-button-smash-hack hacker
########################################################
#                HIVE OVER NFS                         #
# SPIDR          t_'(o_0)"'      daemon summons scroll #
#                                                      #
# grab internet data via queue files                   #
# admin queue-files over the network                   #
# distributive-multi-daemon project management over NFS#
########################################################
use Digest::SHA 'sha256_hex';
use POSIX;
use File::Path;
use File::Copy 'move';
use File::LibMagic;
use LWP::UserAgent;
use LWP::Protocol::https;
########################################################
# DATA LOCATIONS ###############################
# HOST --------------------
# /tmp/$NAME_dump/:    host work dir
# /tmp/PING       :    host PID roster
# NFS ---------------------
# /HIVE/          :    nfs mount
# /HIVE/PING      :    nfs PID roster
# /HIVE/TODO/     :    nfs node-workdir
# /HIVE/FEED/     :    nfs project dir
#                      $FEED/ALL  = all iterations
#                      $FEED/DONE = success list
#                      $FEED/FAIL = failure list
#                      $FEED/QUE/ = que dump
# /HIVE/TOMB/     :    nfs logs
#                      $NAME      = tombsone
#                      RAW_$NAME  = event log
# DUMPSITE ----------------
# /$DUMPPATH/pool/ :   data dump
# /$DUMPPATH/g/    :   metadata dump
# BIRTH ################################################
my ($DUMPPATH, $FEED) = @ARGV;
die "ARG1 dump-site ARG2 FEED" if (!defined $FEED); # FEED: /HIVE/FEED/achive/

die "STILLBORN" if ((my $birth = daemon()) != 0);
# PREP @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
use constant $NAME => name();
# HOST VARIABLES ----------
use constant $HOST => `hostname`;
use constant $DUMP => '/tmp/'.$NAME.'_dump/'; # unique process hostside dump
use constant $HOSTPING => '/tmp/PING';
# NET VARIABLES -----------
use constant $NFSPATH => "/HIVE/";
use constant $NFSPING => $NFSPATH.'PING';
use constant $TOMB => $NFSPATH.'TOMB/'; # DEMON logs
# LOG VARIABLES -----------
use constant $TOMBSTONE => $TOMB.$NAME;
use constant $RAW => $TOMB.'RAW_'.$NAME; # output
use constant $TPATH = '/HIVE/TODO/';
use constant $TODO => $TPATH.$NAME; # leftovers that need to be put back in $FEED
use constant $DONE => $TOMB.'DONE_'.$NAME; # successful iterations
use constant $FAIL => $TOMB.'FAIL_'.$NAME; # failed iterations that need to be cleaned up
use constant $ZOMBIE => $TOMB.'ZOMBIE_'.$NAME; # fails path of api_verify()
# CONTROL VARIABLES -------
use constant $SLEEP => $TOMB.'SLEEP_'.$NAME; # triggers sleep
use constant $SUICIDE => $TOMB.'SUICIDE_'.$NAME; # triggers suicide
# DEMON VARIABLES ---------
use constant $BIRTH => age();
use constant $RATE => 100;
use constant $UA => uagent();
# dumpsite mountpoints ----
use constant $POOL => $DUMPPATH.'pool/';
use constant $G => $DUMPPATH.'g/';
# GLOBALS -----------------
my $YAY = 0; # total sucesses
my $FA = 0;  # total failures
$SIG{INT} = \&SUICIDE;
# PREP --------------------
chdir('/tmp/');
unless (mkdir $DUMP)
	{ print $Lfh "cant create dump $DUMP \n"; exit; }
# OUTPUT ------------------
open(my $Lfh, '>>', $RAW); $Lfh->autoflush(1);
open(my $FAILfh, '>>', $FAIL); $FAILfh->autoflush(1);
open(my $DONEfh, '>>', $DONE); $DONEfh->autoflush(1);

h_ping(); # host roster
n_ping(); # net roster (life clean)

printf $Lfh ("HELLOWORLD %s\n", TIME());

unless (-w $POOL && -w $G)
	{ print $Lfh "cant write dump $DUMPPATH\n"; exit; }
unless (-w $NFSPING)
	{ print $Lfh "PING nonwriteable\n"; exit; }
unless (-w $FEED)
	{ print $Lfh "QUE dump nonwriteable\n"; exit; }
# LIVE &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
while (1)
{
	clean();
	my @QUE = que_up();
	my $count = 0;
	my $ttl = @QUE;

	print $Lfh "ttl $ttl\n";

	foreach my $i (@QUE)
	{
		if (-e $SLEEP)
   	 		{ SLEEP($count, $ttl, @QUE); }
		pluck($i);

		if ($count % $RATE == 0)
		{
			tombstone($count, $ttl);
			que_flush(@QUE);
			n_ping();
		}
		$count++;

	}
	unlink $TODO;
}
# LOGIC %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sub pluck
{
	my ($i) = @_;
	sleep 2;
	my $iname = $i; $iname =~ s?.*/??;
	my $tmp = $DUMP.$iname;
	my $response = $UA->get($i, ':content_file'=>"$tmp");
	if (-e $tmp)
	{
		$YAY++;
		print $DONEfh "$i\n";
		XS($tmp);
	}
	else
	{
		$FA++;
		print $FAILfh "$i\n";
	}
}
# CORE SUBS ////////////////////////////////////////////
sub daemon {
  	die "FAIL daemon1 $!\n" if ((my $pid = fork()) < 0);
   	if ($pid != 0)
   		{ exit(0); }
   	POSIX::setsid() or die "FAIL setsid $!";
   	die "FAIL daemon2 $!\n" if ((my $pid2 = fork()) < 0);
  	if ($pid2 != 0)
   		{ exit(0); }
	chdir('/tmp');
   	umask 0;
   	my $fds = 3;
  	while ($fds < 1024)
   	 	{ POSIX::close($fds); $fds++;  }
   	my $des = '/dev/null';
   	open(STDIN, "<$des");
   	open(STDOUT, ">$des");
   	open(STDERR, ">$des");
   	return 0;
}
# CONTROL -----------------
sub SUICIDE
{
	my ($count, $ttl, @QUE) = @_;
	my $curTIME = TIME();
	printf $Lfh "$curTIME FKTHEWORLD\n";
	dio('OUT');
	tombstone($count, $ttl);
	que_flush(@QUE);
	move($TODO, $FEED);
	exit;
}
sub SLEEP
{
	my ($count, $ttl, @QUE) = @_;
	open(my $Sfh, '<', $SLEEP);
	my $timeout = readline $Sfh; chomp $timeout;
	my $curTIME = TIME();
	print $Lfh "$curTIME SLEEP $timeout\n";
	close $Sfh; unlink $SLEEP;
	SUICIDE($count, $ttl, @QUE) if ($timeout eq "SUICIDE");
	tombstone($count, $ttl);
	sleep $timeout;
}
# REPORT ------------------
sub name
{
	my $id = int(rand(999));
	my $name = $HOST.'_'.$id.'_'.$$;
	return $name;
}
sub tombstone
{
	my ($count, $ttl) = @_;

	my $Ttime = age();
	my $Ntime = TIME();
	my $life = "$BIRTH $Ttime";

	open(my $Tfh, '>>', $TOMBSTONE);
	print $Tfh "$Ntime  yay: $YAY   name: $NAME  age: $life  fails: $FA\n";
}
sub h_ping
{
  open(my $Pfh, '>>', $HOSTPING);
  my $curTIME = TIME();
  printf $Pfh "$curTIME $$\n";
  close $Pfh;
}
sub n_ping
{
  open(my $Dfh, '>>', $NFSPING);
  my $curTIME = TIME();
  printf $Dfh "$curTIME $HOST $NAME\n";
  close $Dfh;
}
sub age
{
	my $age = localtime();
	$age =~ s/..........20..//;
	$age =~ s/^....//;
	$age =~ s/ /_/;
	return $age;
}
sub TIME
{
	my $t = localtime;
	my $mon = (split(/\s+/, $t))[1];
	my $day = (split(/\s+/, $t))[2];
	my $hour = (split(/\s+/, $t))[3];
	my $time = $mon.'_'.$day.'_'.$hour;
	return $time;
}
# QUEUE -------------------
sub que_up
{
  my $que_path = que_get();
  open(my $qfh, '<', $que_path);
  my @QUE = readline $qfh;
  chomp @QUE; close $qfh;
  move($que_path, $TODO);
  return (@QUE);
}
sub que_get
{
  opendir(my $dh, $FEED);
  my @ls = readdir($dh);
  shift(@ls); shift(@ls); # skip "." ".."
  my $que_path = $FEED.$ls[0];
  print $Lfh "que: $que_path\n";
  return $que_path;
}
sub que_flush
{
	my (@QUE) = @_;
	open(my $TODOfh, '>', $TODO);
	print $TODOfh "$_\n" for (@QUE);
	close $TODOfh;
}
# XTRACTION & STANDARDIZE -
sub XS
{
  my ($file) = shift;
  my $sha = file_digest($file); print $Lfh "FAIL sha $file $!" if (!defined $sha);
  move($file, $POOL.$sha);

  my $meta = $G.'g'.$sha;
  unless (eval { open(my $fh, '>>', $meta) })
  {
    print $Lfh "!!!! FAIL meta $sha\n" unless (-e $meta);
    return;
  }
  open(my $mfh, '>>', $meta);
  my $iname = xsname($file); print $Lfh "bad xsname $file\n" if (!defined $iname);
  my $ipath = xspath($file);
  my $isize = xssize($file);
  my $imime = file_mime_encoding($file); print $Lfh "bad xsmime $file\n" if (!defined $imime);

  print $mfh "$iname\n$ipath\n$isize\n$imime\n";
	close $mfh;
}
sub file_digest
{
  my ($file) = @_;
  my $digester = Digest::SHA->new('sha256');
  $digester->addfile( $file, 'b' );
  return $digester->hexdigest;
}
sub xsname
{
	my ($file) = @_;
	$file =~ s?^.*/??;
	return $file;
}
sub xspath
{
	my ($file) = @_;
	$file =~ s?/?_?g;
	return $file;
}
sub file_mime_encoding
{
	my ($file) = @_;
	my $magic = File::LibMagic->new();
	my $info = $magic->info_from_filename($file);
	my $des = $info->{description};
	$des =~ s?[/ ]?.?g;
	$des =~ s/,/_/g;
	my $md = $info->{mime_type};
	$md =~ s?[/ ]?.?g;
	my $enc = sprintf("%s %s %s", $des, $md, $info->{encoding});
	return $enc;
}
sub xssize
{
  my ($file) = @_;
  my $size = -s $file;
  return $size;
}
sub uagent
{
  my $s_ua = LWP::UserAgent->new(
    agent => "Mozilla/50.0.2",
    from => 'punxnotdead',
    timeout => 45);
  return $s_ua;
}
# MAINTAIN ----------------
sub clean
{
  my @demons = glob "$TPATH*";
  shift @demons; shift @demons; # skip "." ".."

  for (@demons)
  {
		if (/$HOST/)
    {
	    my $pid = $_; chomp $pid;
      $pid =~ s/.*_//;

      my @up = `ps $pid`;
      if (!defined $up[1])
      {
		  	my $Tpath = "/HIVE/TODO/$_"; # clean net data
			  move($Tpath, $FEED);

        my $Dpath = $_.'_dump'; # clean host data
        $Dpath =~ "/tmp/$Dpath";
        XS($Dpath);
		  	rmdir($Dpath);
      }
		}
  }
}
