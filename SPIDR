#!/usr/local/bin/perl
use strict; use warnings;
# FreeBSD Only
# unix or you a bitch-button-smash-hack hacker

########################################################
#                HIVE OVER NFS                         #
# SPIDR          t_'(o_0)"'      daemon summons scroll #
########################################################

use Const::Fast 'const';
use Digest::SHA 'sha256_hex';
use POSIX;
use File::Path;
use File::Copy;
use File::LibMagic;
use Sys::Hostname 'hostname';
use LWP::UserAgent;
use LWP::Protocol::https;
use Archive::Any;

# STRUCT #######################################
# /tmp/$NAME_dump/ : host work dir
# /tmp/PING : host PID roster

# /HIVE/ : net nfs mount
# /HIVE/PING : net PID roster
# /HIVE/QUE/ : net queue dump

# /HIVE/cemetery/ : net DEMON memorial (logs)

# /HIVE/$NODE/$NAME/ : daemon specific dir
# /HIVE/$NODE/$hostname/ : net api-que

# /nfsdump/pool/ : net data dump
# /nfsdump/g/ : net metadata dump

# NET-COMM [[ pause, kill, stdout, PID, host_side-dump, bandwidth ]]

# BIRTH
die "STILLBORN" if ((my $birth = daemon()) != 0);

# PREP @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
const my $NAME => name(); # uniq process name

# HOST VARIABLES
const my $DUMP => '/tmp/'.$NAME.'_dump/'; # unique process hostside dump
const my $HOSTPING => '/tmp/PING';

# NET VARIABLES
const my $NFSPATH => "/HIVE/";
const my $NFSPING => $NFSPATH.'PING';
const my $QUEDUMP => $NFSPATH.'QUE/';

const my $NODE => hostname(); # node name

const my $QUE => $NFSPATH.$NODE.'/'.$NAME.'/'; # node path
const my $TOMB => $NFSPATH.'cemetery/'; # DEMON logs
const my $TOMBSTONE => $TOMB.$NAME;

# NET LOG VARIABLES
const my $RAW => $TOMB.'RAW_'.$NAME; # output
const my $TODO => $TOMB.'TODO_'.$NAME; # leftovers that need to be put back in $QUE
const my $DONE => $TOMB.'DONE_'.$NAME; # successful iterations
const my $FAIL => $TOMB.'FAIL_'.$NAME; # failed iterations that need to be cleaned up
const my $ZOMBIE => $TOMB.'ZOMBIE_'.$NAME; # fails path of api_verify()
# NET CONTROL VARIABLES
const my $SLEEP => $TOMB.'SLEEP_'.$NAME; # triggers sleep
const my $SUICIDE => $TOMB.'SUICIDE_'.$NAME; # triggers suicide

# DEMON VARIABLES
const my $BIRTH => age();
const my $RATE => 100;
const my $SIZE => 128000; # BLKR
const my $UA => uagent(); # GET

# DATA DUMP VARIABLES
const my $DUMPPATH => '/bkup10/';
const my $POOL => $DUMPPATH.'pool/'; # remote nfs dump
const my $G => $DUMPPATH.'g/'; # remote nfs dump

# GLOBALS
my $YAY = 0;
my $FA = 0;
$SIG{INT} = \&SUICIDE;

chdir('/tmp/');
mkdir $NFSPATH unless(-e $NFSPATH); mkdir $QUE unless (-e $QUE);
mkdir $TOMB unless (-e $TOMB); mkdir $DUMP or die "$DUMP FAIL\n";

# OUTPUT
open(my $Lfh, '>>', $RAW); $Lfh->autoflush(1);
open(my $FAILfh, '>>', $FAIL); $FAILfh->autoflush(1);
open(my $DONEfh, '>>', $DONE); $DONEfh->autoflush(1);


h_ping(); # host roster
n_ping(); # net roster (life beat)

printf $Lfh ("HELLOWORLD %s\n", TIME());

unless (-w $POOL && -w $G)
	{ print $Lfh "cant write nfs dump dirs\n"; exit; }
unless (-w $NFSPING)
	{ print $Lfh "PING nonwriteable\n"; exit; }
unless (-w $QUEDUMP)
	{ print $Lfh "QUE dump nonwriteable\n"; exit; }

sleep 100; # give admin chance to populate que
# @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

# LIVE &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
while (1)
{
	my $que_count = q_count();
	if ($que_count < 3)
	{ 
		my $curTIME = TIME();
		print $Lfh "$curTIME bored\n"; 
		sleep 3600; 
		next; 
	}
	my @QUE = que_up();
	my $count = 0;
	my $ttl = @QUE;

	if (!defined $QUE[0] && !defined $QUE[1] && !defined $QUE[2])
		{ zombie(@QUE); next; }

	print $Lfh "ttl $ttl\n";

	foreach my $i (@QUE)
	{
		if (-e $SLEEP)
   	 		{ SLEEP( $count, $ttl, @QUE); }
		api($i);

		if ($count % $RATE == 0)
		{
			tombstone($count, $ttl);
			que_flush(@QUE);
			n_ping();
		}
		$count++;
# &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
	}
	unlink $TODO;
}

# CORE SUBS ///////////////////////////////////////////////////////////
sub daemon {
  	die "FAIL daemon1 $!\n" if ((my $pid = fork()) < 0);
   	if ($pid != 0)
   		{ exit(0); }
   	POSIX::setsid() or die "FAIL setsid $!";
   	die "FAIL daemon2 $!\n" if ((my $pid2 = fork()) < 0);
  	if ($pid2 != 0)
   		{ exit(0); }
	chdir('/tmp');
   	umask 0;
   	my $fds = 3;
  	while ($fds < 1024)
   	 	{ POSIX::close($fds); $fds++;  }
   	my $des = '/dev/null';
   	open(STDIN, "<$des");
   	open(STDOUT, ">$des");
   	open(STDERR, ">$des");
   	return 0;
}
sub q_count
{
	opendir(my $qdh, $QUE);
	my @f = readdir $qdh;
	my $que_count = @f;
	return $que_count;
}
sub SUICIDE
{
	my ($count, $ttl, @QUE) = @_;
	unlink $SUICIDE;
	my $curTIME = TIME();
	printf $Lfh "$curTIME FKTHEWORLD\n";
	dio('OUT');
	tombstone($count, $ttl);
	que_flush(@QUE);
	`mv $QUE $QUEDUMP`;
	exit;
}
sub SLEEP
{
	my ($count, $ttl, @QUE) = @_;
	open(my $Sfh, '<', $SLEEP);
	my $timeout = readline $Sfh; chomp $timeout;
	my $curTIME = TIME();
	print $Lfh "$curTIME SLEEP $timeout\n";
	close $Sfh; unlink $SLEEP;
	SUICIDE($count, $ttl, @QUE) if ($timeout eq "SUICIDE");
	tombstone($count, $ttl);
	sleep $timeout;
}
sub age
{
	my $age = localtime();
	$age =~ s/..........20..//;
	$age =~ s/^....//;
	$age =~ s/ /_/;
	return $age;
}
sub TIME
{
	my $t = localtime;
	my $mon = (split(/\s+/, $t))[1];
	my $day = (split(/\s+/, $t))[2];
	my $hour = (split(/\s+/, $t))[3];
	my $time = $mon.'_'.$day.'_'.$hour;
	return $time;
}
sub name
{
	my $id = int(rand(999));
	my $name = $$.'_'.$id;
	return $name;
}
sub tombstone
{
	my ($count, $ttl) = @_;

	my $Ttime = age();
	my $life = "$BIRTH $Ttime";

	open(my $Tfh, '>>', $TOMBSTONE);
	print $Tfh "yay: $YAY    name: $NAME   age: $life\n";
}
# QUEUE
sub que_flush
{
	my (@QUE) = @_;
	open(my $TODOfh, '>', $TODO);
	foreach (@QUE)
		{ print $TODOfh "$_\n"; }
	close $TODOfh;
}
sub zombie
{
	my (@QUE) = @_;
  my $id = int(rand(999));
	my $zpath = $ZOMBIE.$id;
	open(my $zfh, '>', $zpath);
	for (@QUE)
		{ print $zfh "$_\n"; }
	close $zfh;
}
sub que_p
{
  opendir(my $dh, $QUE);
 	my @ls = readdir($dh);
  # skip $ls[0] = . ; $ls[1] = ..;
  my $que_path = $QUE.$ls[2];
	print $Lfh "que: $que_path\n";
  return $que_path;
}
sub que_up
{
  my $que_path = que_p();
	open(my $qfh, '<', $que_path);
	my @QUE = readline $qfh;
  chomp @QUE; close $qfh;
	move($que_path, $TODO);
	return (@QUE);
}
# COMMUNICATION
sub h_ping
{
	open(my $Pfh, '>>', $HOSTPING);
	my $curTIME = TIME();
	printf $Pfh "$curTIME $$\n";
	close $Pfh;
}
sub n_ping
{
	open(my $Dfh, '>>', $NFSPING);
	my $curTIME = TIME();
	printf $Dfh "$curTIME $NAME $NODE\n";
	close $Dfh;
}
# XTRACTION & STANDARDIZE
sub XS
{
	my ($file) = shift;
	my ($sha) = file_digest($file) or die "couldn't sha $file";
	File::Copy::copy($file, $POOL.$sha);
	my $cur = $G.'g'.$sha;
	open(my $fh, '>>', $cur) or die "Meta File Creation FAIL $file";
	printf $fh "%s\n%s\n%s\n%s\n",
		xsname($file),
		xspath($file),
		xssize($file),
		file_mime_encoding($file);
}
sub file_digest
{
	my ($file) = @_;
	my $digester = Digest::SHA->new('sha256');
	$digester->addfile( $file, 'b' );
	return $digester->hexdigest;
}
sub xsname
{
	my ($file) = @_;
	$file =~ s?^.*/??;
	return $file;
}
sub xspath
{
	my ($file) = @_;
	$file =~ s?/?_?g;
	return $file;
}
sub file_mime_encoding
{
	my ($file) = @_;
	my $magic = File::LibMagic->new();
	my $info = $magic->info_from_filename($file);
	my $des = $info->{description};
	$des =~ s?[/ ]?.?g;
	$des =~ s/,/_/g;
	my $md = $info->{mime_type};
	$md =~ s?[/ ]?.?g;
	my $enc = sprintf("%s %s %s", $des, $md, $info->{encoding});
	return $enc;
}
sub xssize
{
	my ($file) = @_;
	my $size = -s $file;
	return $size;
}
sub uagent
{
	my $s_ua = LWP::UserAgent->new(
		agent => "Mozilla/50.0.2",
		from => 'punxnotdead',
		timeout => 45,
	);
	return $s_ua;
}
# ///////////////////////////////////////////////////////////

# LOGIC %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sub api
{
	my ($i) = @_;
	sleep 2;
	my $iname = $i; $iname =~ s?.*/??;
	my $tmp = $DUMP.$iname;
	my $response = $UA->get($i, ':content_file'=>"$tmp");
	if (-e $tmp)
	{
		$YAY++;
		print $DONEfh "$i\n";
		XS($tmp) && unlink($tmp);
	}
	else
	{
		$FA++;
		print $FAILfh "$i\n";
	}
}
